"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/./src/lib/google-api.ts":
/*!*******************************!*\
  !*** ./src/lib/google-api.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoogleApiManager: () => (/* binding */ GoogleApiManager)\n/* harmony export */ });\n/**\n * Google API utilities for Drive integration\n */ const CLIENT_ID = \"YOUR_CLIENT_ID_HERE\";\nconst API_KEY = \"YOUR_API_KEY_HERE\";\nconst SCOPES = 'https://www.googleapis.com/auth/drive.file';\nclass GoogleApiManager {\n    static getInstance() {\n        if (!GoogleApiManager.instance) {\n            GoogleApiManager.instance = new GoogleApiManager();\n        }\n        return GoogleApiManager.instance;\n    }\n    async initialize() {\n        if (this.isInitialized) return;\n        if (this.initPromise) return this.initPromise;\n        this.initPromise = this.doInitialize();\n        return this.initPromise;\n    }\n    async doInitialize() {\n        try {\n            // Check if credentials are available\n            if (!CLIENT_ID || !API_KEY) {\n                throw new Error('Google API credentials not configured. Please set NEXT_PUBLIC_GOOGLE_CLIENT_ID and NEXT_PUBLIC_GOOGLE_API_KEY in your .env.local file.');\n            }\n            // Wait for scripts to be available\n            await this.waitForScripts();\n            // Initialize GAPI\n            await this.initializeGapi();\n            // Initialize GSI\n            await this.initializeGsi();\n            this.isInitialized = true;\n        } catch (error) {\n            console.error('Failed to initialize Google APIs:', error);\n            throw new Error('Google API initialization failed');\n        }\n    }\n    waitForScripts() {\n        return new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                reject(new Error('Google API scripts failed to load'));\n            }, 10000);\n            const checkScripts = ()=>{\n                var _window_google_accounts, _window_google;\n                if ( true && window.gapi && ((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_accounts = _window_google.accounts) === null || _window_google_accounts === void 0 ? void 0 : _window_google_accounts.oauth2)) {\n                    clearTimeout(timeout);\n                    resolve();\n                } else {\n                    setTimeout(checkScripts, 100);\n                }\n            };\n            checkScripts();\n        });\n    }\n    initializeGapi() {\n        return new Promise((resolve, reject)=>{\n            if (!window.gapi) {\n                reject(new Error('GAPI not available'));\n                return;\n            }\n            window.gapi.load('client', async ()=>{\n                try {\n                    await window.gapi.client.init({\n                        apiKey: API_KEY,\n                        discoveryDocs: [\n                            'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'\n                        ]\n                    });\n                    resolve();\n                } catch (error) {\n                    reject(new Error('Failed to initialize GAPI client'));\n                }\n            });\n        });\n    }\n    initializeGsi() {\n        return new Promise((resolve, reject)=>{\n            try {\n                var _window_google_accounts, _window_google;\n                if (!((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_accounts = _window_google.accounts) === null || _window_google_accounts === void 0 ? void 0 : _window_google_accounts.oauth2)) {\n                    reject(new Error('Google Identity Services not available'));\n                    return;\n                }\n                this.tokenClient = window.google.accounts.oauth2.initTokenClient({\n                    client_id: CLIENT_ID,\n                    scope: SCOPES,\n                    callback: (tokenResponse)=>{\n                        if (tokenResponse && tokenResponse.access_token) {\n                            window.gapi.client.setToken({\n                                access_token: tokenResponse.access_token\n                            });\n                        }\n                    },\n                    error_callback: (error)=>{\n                        console.error('GSI Error:', error);\n                    }\n                });\n                resolve();\n            } catch (error) {\n                reject(new Error('Failed to initialize Google Identity Services'));\n            }\n        });\n    }\n    async signIn() {\n        if (!this.tokenClient) {\n            throw new Error('Google API not initialized');\n        }\n        return new Promise((resolve, reject)=>{\n            if (!this.tokenClient) {\n                reject(new Error('Token client not available'));\n                return;\n            }\n            const originalCallback = this.tokenClient.callback;\n            this.tokenClient.callback = (tokenResponse)=>{\n                if (originalCallback) originalCallback(tokenResponse);\n                if (tokenResponse && tokenResponse.access_token) {\n                    resolve();\n                } else {\n                    reject(new Error('Failed to get access token'));\n                }\n            };\n            this.tokenClient.requestAccessToken({\n                prompt: 'consent'\n            });\n        });\n    }\n    signOut() {\n        var _window_gapi;\n        if ((_window_gapi = window.gapi) === null || _window_gapi === void 0 ? void 0 : _window_gapi.client) {\n            const token = window.gapi.client.getToken();\n            if (token) {\n                window.google.accounts.oauth2.revoke(token.access_token, ()=>{});\n            }\n            window.gapi.client.setToken(null);\n        }\n    }\n    isSignedIn() {\n        var _window_gapi_client_getToken, _window_gapi_client, _window_gapi;\n        return !!((_window_gapi = window.gapi) === null || _window_gapi === void 0 ? void 0 : (_window_gapi_client = _window_gapi.client) === null || _window_gapi_client === void 0 ? void 0 : (_window_gapi_client_getToken = _window_gapi_client.getToken()) === null || _window_gapi_client_getToken === void 0 ? void 0 : _window_gapi_client_getToken.access_token);\n    }\n    async uploadFile(blob, filename) {\n        if (!this.isSignedIn()) {\n            throw new Error('Not signed in');\n        }\n        const metadata = {\n            name: filename,\n            mimeType: blob.type\n        };\n        const formBody = new FormData();\n        formBody.append('metadata', new Blob([\n            JSON.stringify(metadata)\n        ], {\n            type: 'application/json'\n        }));\n        formBody.append('file', blob);\n        const token = window.gapi.client.getToken();\n        if (!token) {\n            throw new Error('No access token available');\n        }\n        const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(token.access_token)\n            },\n            body: formBody\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(\"Upload failed: \".concat(errorText));\n        }\n        const driveFile = await response.json();\n        // Make file public\n        await window.gapi.client.drive.permissions.create({\n            fileId: driveFile.id,\n            resource: {\n                role: 'reader',\n                type: 'anyone'\n            }\n        });\n        // Get public link\n        const fileDetails = await window.gapi.client.drive.files.get({\n            fileId: driveFile.id,\n            fields: 'webViewLink'\n        });\n        const publicLink = fileDetails.result.webViewLink;\n        if (!publicLink) {\n            throw new Error('Could not retrieve public link');\n        }\n        return publicLink;\n    }\n    constructor(){\n        this.tokenClient = null;\n        this.isInitialized = false;\n        this.initPromise = null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ29vZ2xlLWFwaS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFRCxNQUFNQSxZQUFZQyxxQkFBd0M7QUFDMUQsTUFBTUcsVUFBVUgsbUJBQXNDO0FBQ3RELE1BQU1LLFNBQVM7QUFRUixNQUFNQztJQU1YLE9BQU9DLGNBQWdDO1FBQ3JDLElBQUksQ0FBQ0QsaUJBQWlCRSxRQUFRLEVBQUU7WUFDOUJGLGlCQUFpQkUsUUFBUSxHQUFHLElBQUlGO1FBQ2xDO1FBQ0EsT0FBT0EsaUJBQWlCRSxRQUFRO0lBQ2xDO0lBRUEsTUFBTUMsYUFBNEI7UUFDaEMsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtRQUN4QixJQUFJLElBQUksQ0FBQ0MsV0FBVyxFQUFFLE9BQU8sSUFBSSxDQUFDQSxXQUFXO1FBRTdDLElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUksQ0FBQ0MsWUFBWTtRQUNwQyxPQUFPLElBQUksQ0FBQ0QsV0FBVztJQUN6QjtJQUVBLE1BQWNDLGVBQThCO1FBQzFDLElBQUk7WUFDRixxQ0FBcUM7WUFDckMsSUFBSSxDQUFDYixhQUFhLENBQUNJLFNBQVM7Z0JBQzFCLE1BQU0sSUFBSVUsTUFBTTtZQUNsQjtZQUVBLG1DQUFtQztZQUNuQyxNQUFNLElBQUksQ0FBQ0MsY0FBYztZQUV6QixrQkFBa0I7WUFDbEIsTUFBTSxJQUFJLENBQUNDLGNBQWM7WUFFekIsaUJBQWlCO1lBQ2pCLE1BQU0sSUFBSSxDQUFDQyxhQUFhO1lBRXhCLElBQUksQ0FBQ04sYUFBYSxHQUFHO1FBQ3ZCLEVBQUUsT0FBT08sT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCxNQUFNLElBQUlKLE1BQU07UUFDbEI7SUFDRjtJQUVRQyxpQkFBZ0M7UUFDdEMsT0FBTyxJQUFJSyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLE1BQU1DLFVBQVVDLFdBQVc7Z0JBQ3pCRixPQUFPLElBQUlSLE1BQU07WUFDbkIs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QUFJN0QsTUFBTSxrQkFBNEIsT0FBVjREO1FBQ3BDO1FBRUEsTUFBTUUsWUFBWSxNQUFNUixTQUFTUyxJQUFJO1FBRXJDLG1CQUFtQjtRQUNuQixNQUFNbkQsT0FBT0MsSUFBSSxDQUFDTSxNQUFNLENBQUM2QyxLQUFLLENBQUNDLFdBQVcsQ0FBQ0MsTUFBTSxDQUFDO1lBQ2hEQyxRQUFRTCxVQUFVTSxFQUFFO1lBQ3BCQyxVQUFVO2dCQUFFQyxNQUFNO2dCQUFVdkIsTUFBTTtZQUFTO1FBQzdDO1FBRUEsa0JBQWtCO1FBQ2xCLE1BQU13QixjQUFjLE1BQU0zRCxPQUFPQyxJQUFJLENBQUNNLE1BQU0sQ0FBQzZDLEtBQUssQ0FBQ1EsS0FBSyxDQUFDQyxHQUFHLENBQUM7WUFDM0ROLFFBQVFMLFVBQVVNLEVBQUU7WUFDcEJNLFFBQVE7UUFDVjtRQUVBLE1BQU1DLGFBQWFKLFlBQVlLLE1BQU0sQ0FBQ0MsV0FBVztRQUNqRCxJQUFJLENBQUNGLFlBQVk7WUFDZixNQUFNLElBQUkzRSxNQUFNO1FBQ2xCO1FBRUEsT0FBTzJFO0lBQ1Q7O2FBek1RcEQsY0FBeUQ7YUFDekQxQixnQkFBZ0I7YUFDaEJDLGNBQW9DOztBQXdNOUMiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvc3JjL2xpYi9nb29nbGUtYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR29vZ2xlIEFQSSB1dGlsaXRpZXMgZm9yIERyaXZlIGludGVncmF0aW9uXG4gKi9cblxuY29uc3QgQ0xJRU5UX0lEID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRDtcbmNvbnN0IEFQSV9LRVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfQVBJX0tFWTtcbmNvbnN0IFNDT1BFUyA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLmZpbGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdvb2dsZUFwaVN0YXRlIHtcbiAgaXNBcGlSZWFkeTogYm9vbGVhbjtcbiAgaXNMb2dnZWRJbjogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBjbGFzcyBHb29nbGVBcGlNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEdvb2dsZUFwaU1hbmFnZXI7XG4gIHByaXZhdGUgdG9rZW5DbGllbnQ6IGdvb2dsZS5hY2NvdW50cy5vYXV0aDIuVG9rZW5DbGllbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIHByaXZhdGUgaW5pdFByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogR29vZ2xlQXBpTWFuYWdlciB7XG4gICAgaWYgKCFHb29nbGVBcGlNYW5hZ2VyLmluc3RhbmNlKSB7XG4gICAgICBHb29nbGVBcGlNYW5hZ2VyLmluc3RhbmNlID0gbmV3IEdvb2dsZUFwaU1hbmFnZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIEdvb2dsZUFwaU1hbmFnZXIuaW5zdGFuY2U7XG4gIH1cblxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5pbml0UHJvbWlzZSkgcmV0dXJuIHRoaXMuaW5pdFByb21pc2U7XG5cbiAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5kb0luaXRpYWxpemUoKTtcbiAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZG9Jbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiBjcmVkZW50aWFscyBhcmUgYXZhaWxhYmxlXG4gICAgICBpZiAoIUNMSUVOVF9JRCB8fCAhQVBJX0tFWSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvb2dsZSBBUEkgY3JlZGVudGlhbHMgbm90IGNvbmZpZ3VyZWQuIFBsZWFzZSBzZXQgTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRCBhbmQgTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkgaW4geW91ciAuZW52LmxvY2FsIGZpbGUuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhaXQgZm9yIHNjcmlwdHMgdG8gYmUgYXZhaWxhYmxlXG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JTY3JpcHRzKCk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgR0FQSVxuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplR2FwaSgpO1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIEdTSVxuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplR3NpKCk7XG4gICAgICBcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIEdvb2dsZSBBUElzOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR29vZ2xlIEFQSSBpbml0aWFsaXphdGlvbiBmYWlsZWQnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHdhaXRGb3JTY3JpcHRzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0dvb2dsZSBBUEkgc2NyaXB0cyBmYWlsZWQgdG8gbG9hZCcpKTtcbiAgICAgIH0sIDEwMDAwKTtcblxuICAgICAgY29uc3QgY2hlY2tTY3JpcHRzID0gKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmdhcGkgJiYgd2luZG93Lmdvb2dsZT8uYWNjb3VudHM/Lm9hdXRoMikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0VGltZW91dChjaGVja1NjcmlwdHMsIDEwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNoZWNrU2NyaXB0cygpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplR2FwaSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF3aW5kb3cuZ2FwaSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdHQVBJIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2luZG93LmdhcGkubG9hZCgnY2xpZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5pbml0KHtcbiAgICAgICAgICAgIGFwaUtleTogQVBJX0tFWSxcbiAgICAgICAgICAgIGRpc2NvdmVyeURvY3M6IFsnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZGlzY292ZXJ5L3YxL2FwaXMvZHJpdmUvdjMvcmVzdCddLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBHQVBJIGNsaWVudCcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVHc2koKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghd2luZG93Lmdvb2dsZT8uYWNjb3VudHM/Lm9hdXRoMikge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0dvb2dsZSBJZGVudGl0eSBTZXJ2aWNlcyBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5DbGllbnQgPSB3aW5kb3cuZ29vZ2xlLmFjY291bnRzLm9hdXRoMi5pbml0VG9rZW5DbGllbnQoe1xuICAgICAgICAgIGNsaWVudF9pZDogQ0xJRU5UX0lELFxuICAgICAgICAgIHNjb3BlOiBTQ09QRVMsXG4gICAgICAgICAgY2FsbGJhY2s6ICh0b2tlblJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmICh0b2tlblJlc3BvbnNlICYmIHRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5nYXBpLmNsaWVudC5zZXRUb2tlbih7IGFjY2Vzc190b2tlbjogdG9rZW5SZXNwb25zZS5hY2Nlc3NfdG9rZW4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcl9jYWxsYmFjazogKGVycm9yOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dTSSBFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBHb29nbGUgSWRlbnRpdHkgU2VydmljZXMnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBzaWduSW4oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnRva2VuQ2xpZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvb2dsZSBBUEkgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy50b2tlbkNsaWVudCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUb2tlbiBjbGllbnQgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcmlnaW5hbENhbGxiYWNrID0gdGhpcy50b2tlbkNsaWVudC5jYWxsYmFjaztcbiAgICAgIHRoaXMudG9rZW5DbGllbnQuY2FsbGJhY2sgPSAodG9rZW5SZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmIChvcmlnaW5hbENhbGxiYWNrKSBvcmlnaW5hbENhbGxiYWNrKHRva2VuUmVzcG9uc2UpO1xuICAgICAgICBpZiAodG9rZW5SZXNwb25zZSAmJiB0b2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGFjY2VzcyB0b2tlbicpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy50b2tlbkNsaWVudC5yZXF1ZXN0QWNjZXNzVG9rZW4oeyBwcm9tcHQ6ICdjb25zZW50JyB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNpZ25PdXQoKTogdm9pZCB7XG4gICAgaWYgKHdpbmRvdy5nYXBpPy5jbGllbnQpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gd2luZG93LmdhcGkuY2xpZW50LmdldFRva2VuKCk7XG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgd2luZG93Lmdvb2dsZS5hY2NvdW50cy5vYXV0aDIucmV2b2tlKHRva2VuLmFjY2Vzc190b2tlbiwgKCkgPT4ge30pO1xuICAgICAgfVxuICAgICAgd2luZG93LmdhcGkuY2xpZW50LnNldFRva2VuKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGlzU2lnbmVkSW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKHdpbmRvdy5nYXBpPy5jbGllbnQ/LmdldFRva2VuKCk/LmFjY2Vzc190b2tlbik7XG4gIH1cblxuICBhc3luYyB1cGxvYWRGaWxlKGJsb2I6IEJsb2IsIGZpbGVuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5pc1NpZ25lZEluKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHNpZ25lZCBpbicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgbmFtZTogZmlsZW5hbWUsXG4gICAgICBtaW1lVHlwZTogYmxvYi50eXBlLFxuICAgIH07XG5cbiAgICBjb25zdCBmb3JtQm9keSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1Cb2R5LmFwcGVuZCgnbWV0YWRhdGEnLCBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSkpO1xuICAgIGZvcm1Cb2R5LmFwcGVuZCgnZmlsZScsIGJsb2IpO1xuXG4gICAgY29uc3QgdG9rZW4gPSB3aW5kb3cuZ2FwaS5jbGllbnQuZ2V0VG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS91cGxvYWQvZHJpdmUvdjMvZmlsZXM/dXBsb2FkVHlwZT1tdWx0aXBhcnQnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW4uYWNjZXNzX3Rva2VufWBcbiAgICAgIH0sXG4gICAgICBib2R5OiBmb3JtQm9keSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVXBsb2FkIGZhaWxlZDogJHtlcnJvclRleHR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZHJpdmVGaWxlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgLy8gTWFrZSBmaWxlIHB1YmxpY1xuICAgIGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5kcml2ZS5wZXJtaXNzaW9ucy5jcmVhdGUoe1xuICAgICAgZmlsZUlkOiBkcml2ZUZpbGUuaWQsXG4gICAgICByZXNvdXJjZTogeyByb2xlOiAncmVhZGVyJywgdHlwZTogJ2FueW9uZScgfVxuICAgIH0pO1xuXG4gICAgLy8gR2V0IHB1YmxpYyBsaW5rXG4gICAgY29uc3QgZmlsZURldGFpbHMgPSBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMuZ2V0KHtcbiAgICAgIGZpbGVJZDogZHJpdmVGaWxlLmlkLFxuICAgICAgZmllbGRzOiAnd2ViVmlld0xpbmsnXG4gICAgfSk7XG5cbiAgICBjb25zdCBwdWJsaWNMaW5rID0gZmlsZURldGFpbHMucmVzdWx0LndlYlZpZXdMaW5rO1xuICAgIGlmICghcHVibGljTGluaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmV0cmlldmUgcHVibGljIGxpbmsnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVibGljTGluaztcbiAgfVxufSJdLCJuYW1lcyI6WyJDTElFTlRfSUQiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRCIsIkFQSV9LRVkiLCJORVhUX1BVQkxJQ19HT09HTEVfQVBJX0tFWSIsIlNDT1BFUyIsIkdvb2dsZUFwaU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiaW5pdGlhbGl6ZSIsImlzSW5pdGlhbGl6ZWQiLCJpbml0UHJvbWlzZSIsImRvSW5pdGlhbGl6ZSIsIkVycm9yIiwid2FpdEZvclNjcmlwdHMiLCJpbml0aWFsaXplR2FwaSIsImluaXRpYWxpemVHc2kiLCJlcnJvciIsImNvbnNvbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2hlY2tTY3JpcHRzIiwid2luZG93IiwiZ2FwaSIsImdvb2dsZSIsImFjY291bnRzIiwib2F1dGgyIiwiY2xlYXJUaW1lb3V0IiwibG9hZCIsImNsaWVudCIsImluaXQiLCJhcGlLZXkiLCJkaXNjb3ZlcnlEb2NzIiwidG9rZW5DbGllbnQiLCJpbml0VG9rZW5DbGllbnQiLCJjbGllbnRfaWQiLCJzY29wZSIsImNhbGxiYWNrIiwidG9rZW5SZXNwb25zZSIsImFjY2Vzc190b2tlbiIsInNldFRva2VuIiwiZXJyb3JfY2FsbGJhY2siLCJzaWduSW4iLCJvcmlnaW5hbENhbGxiYWNrIiwicmVxdWVzdEFjY2Vzc1Rva2VuIiwicHJvbXB0Iiwic2lnbk91dCIsInRva2VuIiwiZ2V0VG9rZW4iLCJyZXZva2UiLCJpc1NpZ25lZEluIiwidXBsb2FkRmlsZSIsImJsb2IiLCJmaWxlbmFtZSIsIm1ldGFkYXRhIiwibmFtZSIsIm1pbWVUeXBlIiwidHlwZSIsImZvcm1Cb2R5IiwiRm9ybURhdGEiLCJhcHBlbmQiLCJCbG9iIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImRyaXZlRmlsZSIsImpzb24iLCJkcml2ZSIsInBlcm1pc3Npb25zIiwiY3JlYXRlIiwiZmlsZUlkIiwiaWQiLCJyZXNvdXJjZSIsInJvbGUiLCJmaWxlRGV0YWlscyIsImZpbGVzIiwiZ2V0IiwiZmllbGRzIiwicHVibGljTGluayIsInJlc3VsdCIsIndlYlZpZXdMaW5rIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/google-api.ts\n"));

/***/ })

});