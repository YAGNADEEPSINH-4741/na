"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/./src/lib/google-api.ts":
/*!*******************************!*\
  !*** ./src/lib/google-api.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoogleApiManager: () => (/* binding */ GoogleApiManager)\n/* harmony export */ });\n/**\n * Google API utilities for Drive integration\n */ const CLIENT_ID = \"850316948462-o5aip3c43p343l4aksg3fn02pcjcqqaa.apps.googleusercontent.com\";\nconst API_KEY = \"AIzaSyBzTH1f_pjyoGLKA9GM2J9Y5VPg0K33nVQ\";\nconst SCOPES = 'https://www.googleapis.com/auth/drive.file';\nclass GoogleApiManager {\n    static getInstance() {\n        if (!GoogleApiManager.instance) {\n            GoogleApiManager.instance = new GoogleApiManager();\n        }\n        return GoogleApiManager.instance;\n    }\n    async initialize() {\n        if (this.isInitialized) return;\n        if (this.initPromise) return this.initPromise;\n        this.initPromise = this.doInitialize();\n        return this.initPromise;\n    }\n    async doInitialize() {\n        try {\n            // Check if credentials are available\n            if (!CLIENT_ID || !API_KEY) {\n                throw new Error('Google API credentials not configured. Please set NEXT_PUBLIC_GOOGLE_CLIENT_ID and NEXT_PUBLIC_GOOGLE_API_KEY in your .env.local file.');\n            }\n            // Wait for scripts to be available\n            await this.waitForScripts();\n            // Initialize GAPI\n            await this.initializeGapi();\n            // Initialize GSI\n            await this.initializeGsi();\n            this.isInitialized = true;\n        } catch (error) {\n            console.error('Failed to initialize Google APIs:', error);\n            throw new Error('Google API initialization failed');\n        }\n    }\n    waitForScripts() {\n        return new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                reject(new Error('Google API scripts failed to load'));\n            }, 10000);\n            const checkScripts = ()=>{\n                var _window_google_accounts, _window_google;\n                if ( true && window.gapi && ((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_accounts = _window_google.accounts) === null || _window_google_accounts === void 0 ? void 0 : _window_google_accounts.oauth2)) {\n                    clearTimeout(timeout);\n                    resolve();\n                } else {\n                    setTimeout(checkScripts, 100);\n                }\n            };\n            checkScripts();\n        });\n    }\n    initializeGapi() {\n        return new Promise((resolve, reject)=>{\n            if (!window.gapi) {\n                reject(new Error('GAPI not available'));\n                return;\n            }\n            window.gapi.load('client', async ()=>{\n                try {\n                    await window.gapi.client.init({\n                        apiKey: API_KEY,\n                        discoveryDocs: [\n                            'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'\n                        ]\n                    });\n                    // Load the Drive API explicitly as a fallback\n                    await window.gapi.client.load('drive', 'v3');\n                    resolve();\n                } catch (error) {\n                    console.error('GAPI client initialization error details:', error);\n                    // Try alternative initialization without discovery docs\n                    try {\n                        await window.gapi.client.init({\n                            apiKey: API_KEY\n                        });\n                        await window.gapi.client.load('drive', 'v3');\n                        resolve();\n                    } catch (fallbackError) {\n                        if (error instanceof Error) {\n                            reject(new Error(\"Failed to initialize GAPI client: \".concat(error.message)));\n                        } else {\n                            reject(new Error(\"Failed to initialize GAPI client: \".concat(JSON.stringify(error))));\n                        }\n                    }\n                }\n            });\n        });\n    }\n    initializeGsi() {\n        return new Promise((resolve, reject)=>{\n            try {\n                var _window_google_accounts, _window_google;\n                if (!((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_accounts = _window_google.accounts) === null || _window_google_accounts === void 0 ? void 0 : _window_google_accounts.oauth2)) {\n                    reject(new Error('Google Identity Services not available'));\n                    return;\n                }\n                this.tokenClient = window.google.accounts.oauth2.initTokenClient({\n                    client_id: CLIENT_ID,\n                    scope: SCOPES,\n                    callback: (tokenResponse)=>{\n                        if (tokenResponse && tokenResponse.access_token) {\n                            window.gapi.client.setToken({\n                                access_token: tokenResponse.access_token\n                            });\n                        }\n                    },\n                    error_callback: (error)=>{\n                        console.error('GSI Error:', error);\n                    }\n                });\n                resolve();\n            } catch (error) {\n                reject(new Error('Failed to initialize Google Identity Services'));\n            }\n        });\n    }\n    async signIn() {\n        if (!this.tokenClient) {\n            throw new Error('Google API not initialized');\n        }\n        return new Promise((resolve, reject)=>{\n            if (!this.tokenClient) {\n                reject(new Error('Token client not available'));\n                return;\n            }\n            const originalCallback = this.tokenClient.callback;\n            this.tokenClient.callback = (tokenResponse)=>{\n                if (originalCallback) originalCallback(tokenResponse);\n                if (tokenResponse && tokenResponse.access_token) {\n                    resolve();\n                } else {\n                    reject(new Error('Failed to get access token'));\n                }\n            };\n            this.tokenClient.requestAccessToken({\n                prompt: 'consent'\n            });\n        });\n    }\n    signOut() {\n        var _window_gapi;\n        if ((_window_gapi = window.gapi) === null || _window_gapi === void 0 ? void 0 : _window_gapi.client) {\n            const token = window.gapi.client.getToken();\n            if (token) {\n                window.google.accounts.oauth2.revoke(token.access_token, ()=>{});\n            }\n            window.gapi.client.setToken(null);\n        }\n    }\n    isSignedIn() {\n        var _window_gapi_client_getToken, _window_gapi_client, _window_gapi;\n        return !!((_window_gapi = window.gapi) === null || _window_gapi === void 0 ? void 0 : (_window_gapi_client = _window_gapi.client) === null || _window_gapi_client === void 0 ? void 0 : (_window_gapi_client_getToken = _window_gapi_client.getToken()) === null || _window_gapi_client_getToken === void 0 ? void 0 : _window_gapi_client_getToken.access_token);\n    }\n    async uploadFile(blob, filename) {\n        if (!this.isSignedIn()) {\n            throw new Error('Not signed in');\n        }\n        const metadata = {\n            name: filename,\n            mimeType: blob.type\n        };\n        const formBody = new FormData();\n        formBody.append('metadata', new Blob([\n            JSON.stringify(metadata)\n        ], {\n            type: 'application/json'\n        }));\n        formBody.append('file', blob);\n        const token = window.gapi.client.getToken();\n        if (!token) {\n            throw new Error('No access token available');\n        }\n        const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(token.access_token)\n            },\n            body: formBody\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(\"Upload failed: \".concat(errorText));\n        }\n        const driveFile = await response.json();\n        // Make file public\n        await window.gapi.client.drive.permissions.create({\n            fileId: driveFile.id,\n            resource: {\n                role: 'reader',\n                type: 'anyone'\n            }\n        });\n        // Get public link\n        const fileDetails = await window.gapi.client.drive.files.get({\n            fileId: driveFile.id,\n            fields: 'webViewLink'\n        });\n        const publicLink = fileDetails.result.webViewLink;\n        if (!publicLink) {\n            throw new Error('Could not retrieve public link');\n        }\n        return publicLink;\n    }\n    constructor(){\n        this.tokenClient = null;\n        this.isInitialized = false;\n        this.initPromise = null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ29vZ2xlLWFwaS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFRCxNQUFNQSxZQUFZQywwRUFBd0M7QUFDMUQsTUFBTUcsVUFBVUgseUNBQXNDO0FBQ3RELE1BQU1LLFNBQVM7QUFRUixNQUFNQztJQU1YLE9BQU9DLGNBQWdDO1FBQ3JDLElBQUksQ0FBQ0QsaUJBQWlCRSxRQUFRLEVBQUU7WUFDOUJGLGlCQUFpQkUsUUFBUSxHQUFHLElBQUlGO1FBQ2xDO1FBQ0EsT0FBT0EsaUJBQWlCRSxRQUFRO0lBQ2xDO0lBRUEsTUFBTUMsYUFBNEI7UUFDaEMsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtRQUN4QixJQUFJLElBQUksQ0FBQ0MsV0FBVyxFQUFFLE9BQU8sSUFBSSxDQUFDQSxXQUFXO1FBRTdDLElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUksQ0FBQ0MsWUFBWTtRQUNwQyxPQUFPLElBQUksQ0FBQ0QsV0FBVztJQUN6QjtJQUVBLE1BQWNDLGVBQThCO1FBQzFDLElBQUk7WUFDRixxQ0FBcUM7WUFDckMsSUFBSSxDQUFDYixhQUFhLENBQUNJLFNBQVM7Z0JBQzFCLE1BQU0sSUFBSVUsTUFBTTtZQUNsQjtZQUVBLG1DQUFtQztZQUNuQyxNQUFNLElBQUksQ0FBQ0MsY0FBYztZQUV6QixrQkFBa0I7WUFDbEIsTUFBTSxJQUFJLENBQUNDLGNBQWM7WUFFekIsaUJBQWlCO1lBQ2pCLE1BQU0sSUFBSSxDQUFDQyxhQUFhO1lBRXhCLElBQUksQ0FBQ04sYUFBYSxHQUFHO1FBQ3ZCLEVBQUUsT0FBT08sT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCxNQUFNLElBQUlKLE1BQU07UUFDbEI7SUFDRjtJQUVRQyxpQkFBZ0M7UUFDdEMsT0FBTyxJQUFJSyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLE1BQU1DLFVBQVVDLFdBQVc7Z0JBQ3pCRixPQUFPLElBQUlSLE1BQU07WUFDbkIsR0FBRztZQUVILE1BQU1XLGVBQWU7b0JBQ2lDQyx5QkFBQUE7Z0JBQXBELElBQUksS0FBNkIsSUFBSUEsT0FBT0MsSUFBSSxNQUFJRCxpQkFBQUEsT0FBT0UsTUFBTSxjQUFiRixzQ0FBQUEsMEJBQUFBLGVBQWVHLFFBQVEsY0FBdkJILDhDQUFBQSx3QkFBeUJJLE1BQU0sR0FBRTtvQkFDbkZDLGFBQWFSO29CQUNiRjtnQkFDRixPQUFPO29CQUNMRyxXQUFXQyxjQUFjO2dCQUMzQjtZQUNGO1lBRUFBO1FBQ0Y7SUFDRjtJQUVRVCxpQkFBZ0M7UUFDdEMsT0FBTyxJQUFJSSxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLElBQUksQ0FBQ0ksT0FBT0MsSUFBSSxFQUFFO2dCQUNoQkwsT0FBTyxJQUFJUixNQUFNO2dCQUNqQjtZQUNGO1lBRUFZLE9BQU9DLElBQUksQ0FBQ0ssSUFBSSxDQUFDLFVBQVU7Z0JBQ3pCLElBQUk7b0JBQ0YsTUFBTU4sT0FBT0MsSUFBSSxDQUFDTSxNQUFNLENBQUNDLElBQUksQ0FBQzt3QkFDNUJDLFFBQVEvQjt3QkFDUmdDLGVBQWU7NEJBQUM7eUJBQTZEO29CQUMvRTtvQkFFQSw4Q0FBOEM7b0JBQzlDLE1BQU1WLE9BQU9DLElBQUksQ0FBQ00sTUFBTSxDQUFDRCxJQUFJLENBQUMsU0FBUztvQkFFdkNYO2dCQUNGLEVBQUUsT0FBT0gsT0FBTztvQkFDZEMsUUFBUUQsS0FBSyxDQUFDLDZDQUE2Q0E7b0JBRTNELHdEQUF3RDtvQkFDeEQsSUFBSTt3QkFDRixNQUFNUSxPQUFPQyxJQUFJLENBQUNNLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDOzRCQUM1QkMsUUFBUS9CO3dCQUNWO3dCQUNBLE1BQU1zQixPQUFPQyxJQUFJLENBQUNNLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLFNBQVM7d0JBQ3ZDWDtvQkFDRixFQUFFLE9BQU9nQixlQUFlO3dCQUN0QixJQUFJbkIsaUJBQWlCSixPQUFPOzRCQUMxQlEsT0FBTyxJQUFJUixNQUFNLHFDQUFtRCxPQUFkSSxNQUFNb0IsT0FBTzt3QkFDckUsT0FBTzs0QkFDTGhCLE9BQU8sSUFBSVIsTUFBTSxxQ0FBMkQsT0FBdEJ5QixLQUFLQyxTQUFTLENBQUN0Qjt3QkFDdkU7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFUUQsZ0JBQStCO1FBQ3JDLE9BQU8sSUFBSUcsUUFBUSxDQUFDQyxTQUFTQztZQUMzQixJQUFJO29CQUNHSSx5QkFBQUE7Z0JBQUwsSUFBSSxHQUFDQSxpQkFBQUEsT0FBT0UsTUFBTSxjQUFiRixzQ0FBQUEsMEJBQUFBLGVBQWVHLFFBQVEsY0FBdkJILDhDQUFBQSx3QkFBeUJJLE1BQU0sR0FBRTtvQkFDcENSLE9BQU8sSUFBSVIsTUFBTTtvQkFDakI7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDMkIsV0FBVyxHQUFHZixPQUFPRSxNQUFNLENBQUNDLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDWSxlQUFlLENBQUM7b0JBQy9EQyxXQUFXM0M7b0JBQ1g0QyxPQUFPdEM7b0JBQ1B1QyxVQUFVLENBQUNDO3dCQUNULElBQUlBLGlCQUFpQkEsY0FBY0MsWUFBWSxFQUFFOzRCQUMvQ3JCLE9BQU9DLElBQUksQ0FBQ00sTUFBTSxDQUFDZSxRQUFRLENBQUM7Z0NBQUVELGNBQWNELGNBQWNDLFlBQVk7NEJBQUM7d0JBQ3pFO29CQUNGO29CQUNBRSxnQkFBZ0IsQ0FBQy9CO3dCQUNmQyxRQUFRRCxLQUFLLENBQUMsY0FBY0E7b0JBQzlCO2dCQUNGO2dCQUVBRztZQUNGLEVBQUUsT0FBT0gsT0FBTztnQkFDZEksT0FBTyxJQUFJUixNQUFNO1lBQ25CO1FBQ0Y7SUFDRjtJQUVBLE1BQU1vQyxTQUF3QjtRQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDVCxXQUFXLEVBQUU7WUFDckIsTUFBTSxJQUFJM0IsTUFBTTtRQUNsQjtRQUVBLE9BQU8sSUFBSU0sUUFBUSxDQUFDQyxTQUFTQztZQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDbUIsV0FBVyxFQUFFO2dCQUNyQm5CLE9BQU8sSUFBSVIsTUFBTTtnQkFDakI7WUFDRjtZQUVBLE1BQU1xQyxtQkFBbUIsSUFBSSxDQUFDVixXQUFXLENBQUNJLFFBQVE7WUFDbEQsSUFBSSxDQUFDSixXQUFXLENBQUNJLFFBQVEsR0FBRyxDQUFDQztnQkFDM0IsSUFBSUssa0JBQWtCQSxpQkFBaUJMO2dCQUN2QyxJQUFJQSxpQkFBaUJBLGNBQWNDLFlBQVksRUFBRTtvQkFDL0MxQjtnQkFDRixPQUFPO29CQUNMQyxPQUFPLElBQUlSLE1BQU07Z0JBQ25CO1lBQ0Y7WUFFQSxJQUFJLENBQUMyQixXQUFXLENBQUNXLGtCQUFrQixDQUFDO2dCQUFFQyxRQUFRO1lBQVU7UUFDMUQ7SUFDRjtJQUVBQyxVQUFnQjtZQUNWNUI7UUFBSixLQUFJQSxlQUFBQSxPQUFPQyxJQUFJLGNBQVhELG1DQUFBQSxhQUFhTyxNQUFNLEVBQUU7WUFDdkIsTUFBTXNCLFFBQVE3QixPQUFPQyxJQUFJLENBQUNNLE1BQU0sQ0FBQ3VCLFFBQVE7WUFDekMsSUFBSUQsT0FBTztnQkFDVDdCLE9BQU9FLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDQyxNQUFNLENBQUMyQixNQUFNLENBQUNGLE1BQU1SLFlBQVksRUFBRSxLQUFPO1lBQ2xFO1lBQ0FyQixPQUFPQyxJQUFJLENBQUNNLE1BQU0sQ0FBQ2UsUUFBUSxDQUFDO1FBQzlCO0lBQ0Y7SUFFQVUsYUFBc0I7WUFDVmhDLDhCQUFBQSxxQkFBQUE7UUFBVixPQUFPLENBQUMsR0FBRUEsZUFBQUEsT0FBT0MsSUFBSSxjQUFYRCxvQ0FBQUEsc0JBQUFBLGFBQWFPLE1BQU0sY0FBbkJQLDJDQUFBQSwrQkFBQUEsb0JBQXFCOEIsUUFBUSxnQkFBN0I5QixtREFBQUEsNkJBQWlDcUIsWUFBWTtJQUN6RDtJQUVBLE1BQU1ZLFdBQVdDLElBQVUsRUFBRUMsUUFBZ0IsRUFBbUI7UUFDOUQsSUFBSSxDQUFDLElBQUksQ0FBQ0gsVUFBVSxJQUFJO1lBQ3RCLE1BQU0sSUFBSTVDLE1BQU07UUFDbEI7UUFFQSxNQUFNZ0QsV0FBVztZQUNmQyxNQUFNRjtZQUNORyxVQUFVSixLQUFLSyxJQUFJO1FBQ3JCO1FBRUEsTUFBTUMsV0FBVyxJQUFJQztRQUNyQkQsU0FBU0UsTUFBTSxDQUFDLFlBQVksSUFBSUMsS0FBSztZQUFDOUIsS0FBS0MsU0FBUyxDQUFDc0I7U0FBVSxFQUFFO1lBQUVHLE1BQU07UUFBbUI7UUFDNUZDLFNBQVNFLE1BQU0sQ0FBQyxRQUFRUjtRQUV4QixNQUFNTCxRQUFRN0IsT0FBT0MsSUFBSSxDQUFDTSxNQUFNLENBQUN1QixRQUFRO1FBQ3pDLElBQUksQ0FBQ0QsT0FBTztZQUNWLE1BQU0sSUFBSXpDLE1BQU07UUFDbEI7UUFFQSxNQUFNd0QsV0FBVyxNQUFNQyxNQUFNLHlFQUF5RTtZQUNwR0MsUUFBUTtZQUNSQyxTQUFTO2dCQUNQLGlCQUFpQixVQUE2QixPQUFuQmxCLE1BQU1SLFlBQVk7WUFDL0M7WUFDQTJCLE1BQU1SO1FBQ1I7UUFFQSxJQUFJLENBQUNJLFNBQVNLLEVBQUUsRUFBRTtZQUNoQixNQUFNQyxZQUFZLE1BQU1OLFNBQVNPLElBQUk7WUFDckMsTUFBTSxJQUFJL0QsTUFBTSxrQkFBNEIsT0FBVjhEO1FBQ3BDO1FBRUEsTUFBTUUsWUFBWSxNQUFNUixTQUFTUyxJQUFJO1FBRXJDLG1CQUFtQjtRQUNuQixNQUFNckQsT0FBT0MsSUFBSSxDQUFDTSxNQUFNLENBQUMrQyxLQUFLLENBQUNDLFdBQVcsQ0FBQ0MsTUFBTSxDQUFDO1lBQ2hEQyxRQUFRTCxVQUFVTSxFQUFFO1lBQ3BCQyxVQUFVO2dCQUFFQyxNQUFNO2dCQUFVckIsTUFBTTtZQUFTO1FBQzdDO1FBRUEsa0JBQWtCO1FBQ2xCLE1BQU1zQixjQUFjLE1BQU03RCxPQUFPQyxJQUFJLENBQUNNLE1BQU0sQ0FBQytDLEtBQUssQ0FBQ1EsS0FBSyxDQUFDQyxHQUFHLENBQUM7WUFDM0ROLFFBQVFMLFVBQVVNLEVBQUU7WUFDcEJNLFFBQVE7UUFDVjtRQUVBLE1BQU1DLGFBQWFKLFlBQVlLLE1BQU0sQ0FBQ0MsV0FBVztRQUNqRCxJQUFJLENBQUNGLFlBQVk7WUFDZixNQUFNLElBQUk3RSxNQUFNO1FBQ2xCO1FBRUEsT0FBTzZFO0lBQ1Q7O2FBNU5RbEQsY0FBeUQ7YUFDekQ5QixnQkFBZ0I7YUFDaEJDLGNBQW9DOztBQTJOOUMiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvc3JjL2xpYi9nb29nbGUtYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR29vZ2xlIEFQSSB1dGlsaXRpZXMgZm9yIERyaXZlIGludGVncmF0aW9uXG4gKi9cblxuY29uc3QgQ0xJRU5UX0lEID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRDtcbmNvbnN0IEFQSV9LRVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfQVBJX0tFWTtcbmNvbnN0IFNDT1BFUyA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLmZpbGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdvb2dsZUFwaVN0YXRlIHtcbiAgaXNBcGlSZWFkeTogYm9vbGVhbjtcbiAgaXNMb2dnZWRJbjogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBjbGFzcyBHb29nbGVBcGlNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEdvb2dsZUFwaU1hbmFnZXI7XG4gIHByaXZhdGUgdG9rZW5DbGllbnQ6IGdvb2dsZS5hY2NvdW50cy5vYXV0aDIuVG9rZW5DbGllbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIHByaXZhdGUgaW5pdFByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogR29vZ2xlQXBpTWFuYWdlciB7XG4gICAgaWYgKCFHb29nbGVBcGlNYW5hZ2VyLmluc3RhbmNlKSB7XG4gICAgICBHb29nbGVBcGlNYW5hZ2VyLmluc3RhbmNlID0gbmV3IEdvb2dsZUFwaU1hbmFnZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIEdvb2dsZUFwaU1hbmFnZXIuaW5zdGFuY2U7XG4gIH1cblxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5pbml0UHJvbWlzZSkgcmV0dXJuIHRoaXMuaW5pdFByb21pc2U7XG5cbiAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5kb0luaXRpYWxpemUoKTtcbiAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZG9Jbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiBjcmVkZW50aWFscyBhcmUgYXZhaWxhYmxlXG4gICAgICBpZiAoIUNMSUVOVF9JRCB8fCAhQVBJX0tFWSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvb2dsZSBBUEkgY3JlZGVudGlhbHMgbm90IGNvbmZpZ3VyZWQuIFBsZWFzZSBzZXQgTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRCBhbmQgTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkgaW4geW91ciAuZW52LmxvY2FsIGZpbGUuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhaXQgZm9yIHNjcmlwdHMgdG8gYmUgYXZhaWxhYmxlXG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JTY3JpcHRzKCk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgR0FQSVxuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplR2FwaSgpO1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIEdTSVxuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplR3NpKCk7XG4gICAgICBcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIEdvb2dsZSBBUElzOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR29vZ2xlIEFQSSBpbml0aWFsaXphdGlvbiBmYWlsZWQnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHdhaXRGb3JTY3JpcHRzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0dvb2dsZSBBUEkgc2NyaXB0cyBmYWlsZWQgdG8gbG9hZCcpKTtcbiAgICAgIH0sIDEwMDAwKTtcblxuICAgICAgY29uc3QgY2hlY2tTY3JpcHRzID0gKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmdhcGkgJiYgd2luZG93Lmdvb2dsZT8uYWNjb3VudHM/Lm9hdXRoMikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0VGltZW91dChjaGVja1NjcmlwdHMsIDEwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNoZWNrU2NyaXB0cygpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplR2FwaSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF3aW5kb3cuZ2FwaSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdHQVBJIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2luZG93LmdhcGkubG9hZCgnY2xpZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5pbml0KHtcbiAgICAgICAgICAgIGFwaUtleTogQVBJX0tFWSxcbiAgICAgICAgICAgIGRpc2NvdmVyeURvY3M6IFsnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZGlzY292ZXJ5L3YxL2FwaXMvZHJpdmUvdjMvcmVzdCddLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvYWQgdGhlIERyaXZlIEFQSSBleHBsaWNpdGx5IGFzIGEgZmFsbGJhY2tcbiAgICAgICAgICBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQubG9hZCgnZHJpdmUnLCAndjMnKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignR0FQSSBjbGllbnQgaW5pdGlhbGl6YXRpb24gZXJyb3IgZGV0YWlsczonLCBlcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IGFsdGVybmF0aXZlIGluaXRpYWxpemF0aW9uIHdpdGhvdXQgZGlzY292ZXJ5IGRvY3NcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmluaXQoe1xuICAgICAgICAgICAgICBhcGlLZXk6IEFQSV9LRVksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5sb2FkKCdkcml2ZScsICd2MycpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIEdBUEkgY2xpZW50OiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgR0FQSSBjbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplR3NpKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXdpbmRvdy5nb29nbGU/LmFjY291bnRzPy5vYXV0aDIpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdHb29nbGUgSWRlbnRpdHkgU2VydmljZXMgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRva2VuQ2xpZW50ID0gd2luZG93Lmdvb2dsZS5hY2NvdW50cy5vYXV0aDIuaW5pdFRva2VuQ2xpZW50KHtcbiAgICAgICAgICBjbGllbnRfaWQ6IENMSUVOVF9JRCxcbiAgICAgICAgICBzY29wZTogU0NPUEVTLFxuICAgICAgICAgIGNhbGxiYWNrOiAodG9rZW5SZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZXNwb25zZSAmJiB0b2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICB3aW5kb3cuZ2FwaS5jbGllbnQuc2V0VG9rZW4oeyBhY2Nlc3NfdG9rZW46IHRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3JfY2FsbGJhY2s6IChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHU0kgRXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgR29vZ2xlIElkZW50aXR5IFNlcnZpY2VzJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2lnbkluKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy50b2tlbkNsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb29nbGUgQVBJIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMudG9rZW5DbGllbnQpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVG9rZW4gY2xpZW50IG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3JpZ2luYWxDYWxsYmFjayA9IHRoaXMudG9rZW5DbGllbnQuY2FsbGJhY2s7XG4gICAgICB0aGlzLnRva2VuQ2xpZW50LmNhbGxiYWNrID0gKHRva2VuUmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICBpZiAob3JpZ2luYWxDYWxsYmFjaykgb3JpZ2luYWxDYWxsYmFjayh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHRva2VuUmVzcG9uc2UgJiYgdG9rZW5SZXNwb25zZS5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2Nlc3MgdG9rZW4nKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMudG9rZW5DbGllbnQucmVxdWVzdEFjY2Vzc1Rva2VuKHsgcHJvbXB0OiAnY29uc2VudCcgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzaWduT3V0KCk6IHZvaWQge1xuICAgIGlmICh3aW5kb3cuZ2FwaT8uY2xpZW50KSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHdpbmRvdy5nYXBpLmNsaWVudC5nZXRUb2tlbigpO1xuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIHdpbmRvdy5nb29nbGUuYWNjb3VudHMub2F1dGgyLnJldm9rZSh0b2tlbi5hY2Nlc3NfdG9rZW4sICgpID0+IHt9KTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5nYXBpLmNsaWVudC5zZXRUb2tlbihudWxsKTtcbiAgICB9XG4gIH1cblxuICBpc1NpZ25lZEluKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhISh3aW5kb3cuZ2FwaT8uY2xpZW50Py5nZXRUb2tlbigpPy5hY2Nlc3NfdG9rZW4pO1xuICB9XG5cbiAgYXN5bmMgdXBsb2FkRmlsZShibG9iOiBCbG9iLCBmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuaXNTaWduZWRJbigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzaWduZWQgaW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgIG5hbWU6IGZpbGVuYW1lLFxuICAgICAgbWltZVR5cGU6IGJsb2IudHlwZSxcbiAgICB9O1xuXG4gICAgY29uc3QgZm9ybUJvZHkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtQm9keS5hcHBlbmQoJ21ldGFkYXRhJywgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KG1ldGFkYXRhKV0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pKTtcbiAgICBmb3JtQm9keS5hcHBlbmQoJ2ZpbGUnLCBibG9iKTtcblxuICAgIGNvbnN0IHRva2VuID0gd2luZG93LmdhcGkuY2xpZW50LmdldFRva2VuKCk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vdXBsb2FkL2RyaXZlL3YzL2ZpbGVzP3VwbG9hZFR5cGU9bXVsdGlwYXJ0Jywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VuLmFjY2Vzc190b2tlbn1gXG4gICAgICB9LFxuICAgICAgYm9keTogZm9ybUJvZHksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVwbG9hZCBmYWlsZWQ6ICR7ZXJyb3JUZXh0fWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRyaXZlRmlsZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIC8vIE1ha2UgZmlsZSBwdWJsaWNcbiAgICBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUucGVybWlzc2lvbnMuY3JlYXRlKHtcbiAgICAgIGZpbGVJZDogZHJpdmVGaWxlLmlkLFxuICAgICAgcmVzb3VyY2U6IHsgcm9sZTogJ3JlYWRlcicsIHR5cGU6ICdhbnlvbmUnIH1cbiAgICB9KTtcblxuICAgIC8vIEdldCBwdWJsaWMgbGlua1xuICAgIGNvbnN0IGZpbGVEZXRhaWxzID0gYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmRyaXZlLmZpbGVzLmdldCh7XG4gICAgICBmaWxlSWQ6IGRyaXZlRmlsZS5pZCxcbiAgICAgIGZpZWxkczogJ3dlYlZpZXdMaW5rJ1xuICAgIH0pO1xuXG4gICAgY29uc3QgcHVibGljTGluayA9IGZpbGVEZXRhaWxzLnJlc3VsdC53ZWJWaWV3TGluaztcbiAgICBpZiAoIXB1YmxpY0xpbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJldHJpZXZlIHB1YmxpYyBsaW5rJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1YmxpY0xpbms7XG4gIH1cbn0iXSwibmFtZXMiOlsiQ0xJRU5UX0lEIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0dPT0dMRV9DTElFTlRfSUQiLCJBUElfS0VZIiwiTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkiLCJTQ09QRVMiLCJHb29nbGVBcGlNYW5hZ2VyIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImluaXRpYWxpemUiLCJpc0luaXRpYWxpemVkIiwiaW5pdFByb21pc2UiLCJkb0luaXRpYWxpemUiLCJFcnJvciIsIndhaXRGb3JTY3JpcHRzIiwiaW5pdGlhbGl6ZUdhcGkiLCJpbml0aWFsaXplR3NpIiwiZXJyb3IiLCJjb25zb2xlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImNoZWNrU2NyaXB0cyIsIndpbmRvdyIsImdhcGkiLCJnb29nbGUiLCJhY2NvdW50cyIsIm9hdXRoMiIsImNsZWFyVGltZW91dCIsImxvYWQiLCJjbGllbnQiLCJpbml0IiwiYXBpS2V5IiwiZGlzY292ZXJ5RG9jcyIsImZhbGxiYWNrRXJyb3IiLCJtZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsInRva2VuQ2xpZW50IiwiaW5pdFRva2VuQ2xpZW50IiwiY2xpZW50X2lkIiwic2NvcGUiLCJjYWxsYmFjayIsInRva2VuUmVzcG9uc2UiLCJhY2Nlc3NfdG9rZW4iLCJzZXRUb2tlbiIsImVycm9yX2NhbGxiYWNrIiwic2lnbkluIiwib3JpZ2luYWxDYWxsYmFjayIsInJlcXVlc3RBY2Nlc3NUb2tlbiIsInByb21wdCIsInNpZ25PdXQiLCJ0b2tlbiIsImdldFRva2VuIiwicmV2b2tlIiwiaXNTaWduZWRJbiIsInVwbG9hZEZpbGUiLCJibG9iIiwiZmlsZW5hbWUiLCJtZXRhZGF0YSIsIm5hbWUiLCJtaW1lVHlwZSIsInR5cGUiLCJmb3JtQm9keSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiQmxvYiIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImRyaXZlRmlsZSIsImpzb24iLCJkcml2ZSIsInBlcm1pc3Npb25zIiwiY3JlYXRlIiwiZmlsZUlkIiwiaWQiLCJyZXNvdXJjZSIsInJvbGUiLCJmaWxlRGV0YWlscyIsImZpbGVzIiwiZ2V0IiwiZmllbGRzIiwicHVibGljTGluayIsInJlc3VsdCIsIndlYlZpZXdMaW5rIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/google-api.ts\n"));

/***/ })

});