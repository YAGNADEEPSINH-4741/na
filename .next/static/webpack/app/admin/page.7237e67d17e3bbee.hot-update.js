"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/./src/lib/google-api.ts":
/*!*******************************!*\
  !*** ./src/lib/google-api.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoogleApiManager: () => (/* binding */ GoogleApiManager)\n/* harmony export */ });\n/**\n * Google API utilities for Drive integration\n */ const CLIENT_ID = \"850316948462-o5aip3c43p343l4aksg3fn02pcjcqqaa.apps.googleusercontent.com\";\nconst API_KEY = \"AIzaSyBzTH1f_pjyoGLKA9GM2J9Y5VPg0K33nVQ\";\nconst SCOPES = 'https://www.googleapis.com/auth/drive.file';\nclass GoogleApiManager {\n    static getInstance() {\n        if (!GoogleApiManager.instance) {\n            GoogleApiManager.instance = new GoogleApiManager();\n        }\n        return GoogleApiManager.instance;\n    }\n    async initialize() {\n        if (this.isInitialized) return;\n        if (this.initPromise) return this.initPromise;\n        this.initPromise = this.doInitialize();\n        return this.initPromise;\n    }\n    async doInitialize() {\n        try {\n            // Check if credentials are available\n            if (!CLIENT_ID || !API_KEY) {\n                throw new Error('Google API credentials not configured. Please set NEXT_PUBLIC_GOOGLE_CLIENT_ID and NEXT_PUBLIC_GOOGLE_API_KEY in your .env.local file.');\n            }\n            // Wait for scripts to be available\n            await this.waitForScripts();\n            // Initialize GAPI\n            await this.initializeGapi();\n            // Initialize GSI\n            await this.initializeGsi();\n            this.isInitialized = true;\n        } catch (error) {\n            console.error('Failed to initialize Google APIs:', error);\n            throw new Error('Google API initialization failed');\n        }\n    }\n    waitForScripts() {\n        return new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                reject(new Error('Google API scripts failed to load'));\n            }, 10000);\n            const checkScripts = ()=>{\n                var _window_google_accounts, _window_google;\n                if ( true && window.gapi && ((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_accounts = _window_google.accounts) === null || _window_google_accounts === void 0 ? void 0 : _window_google_accounts.oauth2)) {\n                    clearTimeout(timeout);\n                    resolve();\n                } else {\n                    setTimeout(checkScripts, 100);\n                }\n            };\n            checkScripts();\n        });\n    }\n    initializeGapi() {\n        return new Promise((resolve, reject)=>{\n            if (!window.gapi) {\n                reject(new Error('GAPI not available'));\n                return;\n            }\n            window.gapi.load('client', async ()=>{\n                try {\n                    await window.gapi.client.init({\n                        apiKey: API_KEY,\n                        discoveryDocs: [\n                            'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'\n                        ]\n                    });\n                    resolve();\n                } catch (error) {\n                    console.error('GAPI client initialization error details:', error);\n                    if (error instanceof Error) {\n                        reject(new Error(\"Failed to initialize GAPI client: \".concat(error.message)));\n                    } else {\n                        reject(new Error(\"Failed to initialize GAPI client: \".concat(JSON.stringify(error))));\n                    }\n                }\n            });\n        });\n    }\n    initializeGsi() {\n        return new Promise((resolve, reject)=>{\n            try {\n                var _window_google_accounts, _window_google;\n                if (!((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_accounts = _window_google.accounts) === null || _window_google_accounts === void 0 ? void 0 : _window_google_accounts.oauth2)) {\n                    reject(new Error('Google Identity Services not available'));\n                    return;\n                }\n                this.tokenClient = window.google.accounts.oauth2.initTokenClient({\n                    client_id: CLIENT_ID,\n                    scope: SCOPES,\n                    callback: (tokenResponse)=>{\n                        if (tokenResponse && tokenResponse.access_token) {\n                            window.gapi.client.setToken({\n                                access_token: tokenResponse.access_token\n                            });\n                        }\n                    },\n                    error_callback: (error)=>{\n                        console.error('GSI Error:', error);\n                    }\n                });\n                resolve();\n            } catch (error) {\n                reject(new Error('Failed to initialize Google Identity Services'));\n            }\n        });\n    }\n    async signIn() {\n        if (!this.tokenClient) {\n            throw new Error('Google API not initialized');\n        }\n        return new Promise((resolve, reject)=>{\n            if (!this.tokenClient) {\n                reject(new Error('Token client not available'));\n                return;\n            }\n            const originalCallback = this.tokenClient.callback;\n            this.tokenClient.callback = (tokenResponse)=>{\n                if (originalCallback) originalCallback(tokenResponse);\n                if (tokenResponse && tokenResponse.access_token) {\n                    resolve();\n                } else {\n                    reject(new Error('Failed to get access token'));\n                }\n            };\n            this.tokenClient.requestAccessToken({\n                prompt: 'consent'\n            });\n        });\n    }\n    signOut() {\n        var _window_gapi;\n        if ((_window_gapi = window.gapi) === null || _window_gapi === void 0 ? void 0 : _window_gapi.client) {\n            const token = window.gapi.client.getToken();\n            if (token) {\n                window.google.accounts.oauth2.revoke(token.access_token, ()=>{});\n            }\n            window.gapi.client.setToken(null);\n        }\n    }\n    isSignedIn() {\n        var _window_gapi_client_getToken, _window_gapi_client, _window_gapi;\n        return !!((_window_gapi = window.gapi) === null || _window_gapi === void 0 ? void 0 : (_window_gapi_client = _window_gapi.client) === null || _window_gapi_client === void 0 ? void 0 : (_window_gapi_client_getToken = _window_gapi_client.getToken()) === null || _window_gapi_client_getToken === void 0 ? void 0 : _window_gapi_client_getToken.access_token);\n    }\n    async uploadFile(blob, filename) {\n        if (!this.isSignedIn()) {\n            throw new Error('Not signed in');\n        }\n        const metadata = {\n            name: filename,\n            mimeType: blob.type\n        };\n        const formBody = new FormData();\n        formBody.append('metadata', new Blob([\n            JSON.stringify(metadata)\n        ], {\n            type: 'application/json'\n        }));\n        formBody.append('file', blob);\n        const token = window.gapi.client.getToken();\n        if (!token) {\n            throw new Error('No access token available');\n        }\n        const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(token.access_token)\n            },\n            body: formBody\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(\"Upload failed: \".concat(errorText));\n        }\n        const driveFile = await response.json();\n        // Make file public\n        await window.gapi.client.drive.permissions.create({\n            fileId: driveFile.id,\n            resource: {\n                role: 'reader',\n                type: 'anyone'\n            }\n        });\n        // Get public link\n        const fileDetails = await window.gapi.client.drive.files.get({\n            fileId: driveFile.id,\n            fields: 'webViewLink'\n        });\n        const publicLink = fileDetails.result.webViewLink;\n        if (!publicLink) {\n            throw new Error('Could not retrieve public link');\n        }\n        return publicLink;\n    }\n    constructor(){\n        this.tokenClient = null;\n        this.isInitialized = false;\n        this.initPromise = null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ29vZ2xlLWFwaS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFRCxNQUFNQSxZQUFZQywwRUFBd0M7QUFDMUQsTUFBTUcsVUFBVUgseUNBQXNDO0FBQ3RELE1BQU1LLFNBQVM7QUFRUixNQUFNQztJQU1YLE9BQU9DLGNBQWdDO1FBQ3JDLElBQUksQ0FBQ0QsaUJBQWlCRSxRQUFRLEVBQUU7WUFDOUJGLGlCQUFpQkUsUUFBUSxHQUFHLElBQUlGO1FBQ2xDO1FBQ0EsT0FBT0EsaUJBQWlCRSxRQUFRO0lBQ2xDO0lBRUEsTUFBTUMsYUFBNEI7UUFDaEMsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtRQUN4QixJQUFJLElBQUksQ0FBQ0MsV0FBVyxFQUFFLE9BQU8sSUFBSSxDQUFDQSxXQUFXO1FBRTdDLElBQUksQ0FBQ0EsV0FBVyxHQUFHLElBQUksQ0FBQ0MsWUFBWTtRQUNwQyxPQUFPLElBQUksQ0FBQ0QsV0FBVztJQUN6QjtJQUVBLE1BQWNDLGVBQThCO1FBQzFDLElBQUk7WUFDRixxQ0FBcUM7WUFDckMsSUFBSSxDQUFDYixhQUFhLENBQUNJLFNBQVM7Z0JBQzFCLE1BQU0sSUFBSVUsTUFBTTtZQUNsQjtZQUVBLG1DQUFtQztZQUNuQyxNQUFNLElBQUksQ0FBQ0MsY0FBYztZQUV6QixrQkFBa0I7WUFDbEIsTUFBTSxJQUFJLENBQUNDLGNBQWM7WUFFekIsaUJBQWlCO1lBQ2pCLE1BQU0sSUFBSSxDQUFDQyxhQUFhO1lBRXhCLElBQUksQ0FBQ04sYUFBYSxHQUFHO1FBQ3ZCLEVBQUUsT0FBT08sT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtZQUNuRCxNQUFNLElBQUlKLE1BQU07UUFDbEI7SUFDRjtJQUVRQyxpQkFBZ0M7UUFDdEMsT0FBTyxJQUFJSyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLE1BQU1DLFVBQVVDLFdBQVc7Z0JBQ3pCRixPQUFPLElBQUlSLE1BQU07WUFDbkIsR0FBRztZQUVILE1BQU1XLGVBQWU7b0JBQ2lDQyx5QkFBQUE7Z0JBQXBELElBQUksS0FBNkIsSUFBSUEsT0FBT0MsSUFBSSxNQUFJRCxpQkFBQUEsT0FBT0UsTUFBTSxjQUFiRixzQ0FBQUEsMEJBQUFBLGVBQWVHLFFBQVEsY0FBdkJILDhDQUFBQSx3QkFBeUJJLE1BQU0sR0FBRTtvQkFDbkZDLGFBQWFSO29CQUNiRjtnQkFDRixPQUFPO29CQUNMRyxXQUFXQyxjQUFjO2dCQUMzQjtZQUNGO1lBRUFBO1FBQ0Y7SUFDRjtJQUVRVCxpQkFBZ0M7UUFDdEMsT0FBTyxJQUFJSSxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLElBQUksQ0FBQ0ksT0FBT0MsSUFBSSxFQUFFO2dCQUNoQkwsT0FBTyxJQUFJUixNQUFNO2dCQUNqQjtZQUNGO1lBRUFZLE9BQU9DLElBQUksQ0FBQ0ssSUFBSSxDQUFDLFVBQVU7Z0JBQ3pCLElBQUk7b0JBQ0YsTUFBTU4sT0FBT0MsSUFBSSxDQUFDTSxNQUFNLENBQUNDLElBQUksQ0FBQzt3QkFDNUJDLFFBQVEvQjt3QkFDUmdDLGVBQWU7NEJBQUM7eUJBQTZEO29CQUMvRTtvQkFDQWY7Z0JBQ0YsRUFBRSxPQUFPSCxPQUFPO29CQUNkQyxRQUFRRCxLQUFLLENBQUMsNkNBQTZDQTtvQkFDM0QsSUFBSUEsaUJBQWlCSixPQUFPO3dCQUMxQlEsT0FBTyxJQUFJUixNQUFNLHFDQUFtRCxPQUFkSSxNQUFNbUIsT0FBTztvQkFDckUsT0FBTzt3QkFDTGYsT0FBTyxJQUFJUixNQUFNLHFDQUEyRCxPQUF0QndCLEtBQUtDLFNBQVMsQ0FBQ3JCO29CQUN2RTtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVRRCxnQkFBK0I7UUFDckMsT0FBTyxJQUFJRyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLElBQUk7b0JBQ0dJLHlCQUFBQTtnQkFBTCxJQUFJLEdBQUNBLGlCQUFBQSxPQUFPRSxNQUFNLGNBQWJGLHNDQUFBQSwwQkFBQUEsZUFBZUcsUUFBUSxjQUF2QkgsOENBQUFBLHdCQUF5QkksTUFBTSxHQUFFO29CQUNwQ1IsT0FBTyxJQUFJUixNQUFNO29CQUNqQjtnQkFDRjtnQkFFQSxJQUFJLENBQUMwQixXQUFXLEdBQUdkLE9BQU9FLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDQyxNQUFNLENBQUNXLGVBQWUsQ0FBQztvQkFDL0RDLFdBQVcxQztvQkFDWDJDLE9BQU9yQztvQkFDUHNDLFVBQVUsQ0FBQ0M7d0JBQ1QsSUFBSUEsaUJBQWlCQSxjQUFjQyxZQUFZLEVBQUU7NEJBQy9DcEIsT0FBT0MsSUFBSSxDQUFDTSxNQUFNLENBQUNjLFFBQVEsQ0FBQztnQ0FBRUQsY0FBY0QsY0FBY0MsWUFBWTs0QkFBQzt3QkFDekU7b0JBQ0Y7b0JBQ0FFLGdCQUFnQixDQUFDOUI7d0JBQ2ZDLFFBQVFELEtBQUssQ0FBQyxjQUFjQTtvQkFDOUI7Z0JBQ0Y7Z0JBRUFHO1lBQ0YsRUFBRSxPQUFPSCxPQUFPO2dCQUNkSSxPQUFPLElBQUlSLE1BQU07WUFDbkI7UUFDRjtJQUNGO0lBRUEsTUFBTW1DLFNBQXdCO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUNULFdBQVcsRUFBRTtZQUNyQixNQUFNLElBQUkxQixNQUFNO1FBQ2xCO1FBRUEsT0FBTyxJQUFJTSxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNrQixXQUFXLEVBQUU7Z0JBQ3JCbEIsT0FBTyxJQUFJUixNQUFNO2dCQUNqQjtZQUNGO1lBRUEsTUFBTW9DLG1CQUFtQixJQUFJLENBQUNWLFdBQVcsQ0FBQ0ksUUFBUTtZQUNsRCxJQUFJLENBQUNKLFdBQVcsQ0FBQ0ksUUFBUSxHQUFHLENBQUNDO2dCQUMzQixJQUFJSyxrQkFBa0JBLGlCQUFpQkw7Z0JBQ3ZDLElBQUlBLGlCQUFpQkEsY0FBY0MsWUFBWSxFQUFFO29CQUMvQ3pCO2dCQUNGLE9BQU87b0JBQ0xDLE9BQU8sSUFBSVIsTUFBTTtnQkFDbkI7WUFDRjtZQUVBLElBQUksQ0FBQzBCLFdBQVcsQ0FBQ1csa0JBQWtCLENBQUM7Z0JBQUVDLFFBQVE7WUFBVTtRQUMxRDtJQUNGO0lBRUFDLFVBQWdCO1lBQ1YzQjtRQUFKLEtBQUlBLGVBQUFBLE9BQU9DLElBQUksY0FBWEQsbUNBQUFBLGFBQWFPLE1BQU0sRUFBRTtZQUN2QixNQUFNcUIsUUFBUTVCLE9BQU9DLElBQUksQ0FBQ00sTUFBTSxDQUFDc0IsUUFBUTtZQUN6QyxJQUFJRCxPQUFPO2dCQUNUNUIsT0FBT0UsTUFBTSxDQUFDQyxRQUFRLENBQUNDLE1BQU0sQ0FBQzBCLE1BQU0sQ0FBQ0YsTUFBTVIsWUFBWSxFQUFFLEtBQU87WUFDbEU7WUFDQXBCLE9BQU9DLElBQUksQ0FBQ00sTUFBTSxDQUFDYyxRQUFRLENBQUM7UUFDOUI7SUFDRjtJQUVBVSxhQUFzQjtZQUNWL0IsOEJBQUFBLHFCQUFBQTtRQUFWLE9BQU8sQ0FBQyxHQUFFQSxlQUFBQSxPQUFPQyxJQUFJLGNBQVhELG9DQUFBQSxzQkFBQUEsYUFBYU8sTUFBTSxjQUFuQlAsMkNBQUFBLCtCQUFBQSxvQkFBcUI2QixRQUFRLGdCQUE3QjdCLG1EQUFBQSw2QkFBaUNvQixZQUFZO0lBQ3pEO0lBRUEsTUFBTVksV0FBV0MsSUFBVSxFQUFFQyxRQUFnQixFQUFtQjtRQUM5RCxJQUFJLENBQUMsSUFBSSxDQUFDSCxVQUFVLElBQUk7WUFDdEIsTUFBTSxJQUFJM0MsTUFBTTtRQUNsQjtRQUVBLE1BQU0rQyxXQUFXO1lBQ2ZDLE1BQU1GO1lBQ05HLFVBQVVKLEtBQUtLLElBQUk7UUFDckI7UUFFQSxNQUFNQyxXQUFXLElBQUlDO1FBQ3JCRCxTQUFTRSxNQUFNLENBQUMsWUFBWSxJQUFJQyxLQUFLO1lBQUM5QixLQUFLQyxTQUFTLENBQUNzQjtTQUFVLEVBQUU7WUFBRUcsTUFBTTtRQUFtQjtRQUM1RkMsU0FBU0UsTUFBTSxDQUFDLFFBQVFSO1FBRXhCLE1BQU1MLFFBQVE1QixPQUFPQyxJQUFJLENBQUNNLE1BQU0sQ0FBQ3NCLFFBQVE7UUFDekMsSUFBSSxDQUFDRCxPQUFPO1lBQ1YsTUFBTSxJQUFJeEMsTUFBTTtRQUNsQjtRQUVBLE1BQU11RCxXQUFXLE1BQU1DLE1BQU0seUVBQXlFO1lBQ3BHQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsaUJBQWlCLFVBQTZCLE9BQW5CbEIsTUFBTVIsWUFBWTtZQUMvQztZQUNBMkIsTUFBTVI7UUFDUjtRQUVBLElBQUksQ0FBQ0ksU0FBU0ssRUFBRSxFQUFFO1lBQ2hCLE1BQU1DLFlBQVksTUFBTU4sU0FBU08sSUFBSTtZQUNyQyxNQUFNLElBQUk5RCxNQUFNLGtCQUE0QixPQUFWNkQ7UUFDcEM7UUFFQSxNQUFNRSxZQUFZLE1BQU1SLFNBQVNTLElBQUk7UUFFckMsbUJBQW1CO1FBQ25CLE1BQU1wRCxPQUFPQyxJQUFJLENBQUNNLE1BQU0sQ0FBQzhDLEtBQUssQ0FBQ0MsV0FBVyxDQUFDQyxNQUFNLENBQUM7WUFDaERDLFFBQVFMLFVBQVVNLEVBQUU7WUFDcEJDLFVBQVU7Z0JBQUVDLE1BQU07Z0JBQVVyQixNQUFNO1lBQVM7UUFDN0M7UUFFQSxrQkFBa0I7UUFDbEIsTUFBTXNCLGNBQWMsTUFBTTVELE9BQU9DLElBQUksQ0FBQ00sTUFBTSxDQUFDOEMsS0FBSyxDQUFDUSxLQUFLLENBQUNDLEdBQUcsQ0FBQztZQUMzRE4sUUFBUUwsVUFBVU0sRUFBRTtZQUNwQk0sUUFBUTtRQUNWO1FBRUEsTUFBTUMsYUFBYUosWUFBWUssTUFBTSxDQUFDQyxXQUFXO1FBQ2pELElBQUksQ0FBQ0YsWUFBWTtZQUNmLE1BQU0sSUFBSTVFLE1BQU07UUFDbEI7UUFFQSxPQUFPNEU7SUFDVDs7YUE5TVFsRCxjQUF5RDthQUN6RDdCLGdCQUFnQjthQUNoQkMsY0FBb0M7O0FBNk05QyIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9zcmMvbGliL2dvb2dsZS1hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHb29nbGUgQVBJIHV0aWxpdGllcyBmb3IgRHJpdmUgaW50ZWdyYXRpb25cbiAqL1xuXG5jb25zdCBDTElFTlRfSUQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfQ0xJRU5UX0lEO1xuY29uc3QgQVBJX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9BUElfS0VZO1xuY29uc3QgU0NPUEVTID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZHJpdmUuZmlsZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR29vZ2xlQXBpU3RhdGUge1xuICBpc0FwaVJlYWR5OiBib29sZWFuO1xuICBpc0xvZ2dlZEluOiBib29sZWFuO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGNsYXNzIEdvb2dsZUFwaU1hbmFnZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogR29vZ2xlQXBpTWFuYWdlcjtcbiAgcHJpdmF0ZSB0b2tlbkNsaWVudDogZ29vZ2xlLmFjY291bnRzLm9hdXRoMi5Ub2tlbkNsaWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBpbml0UHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBHb29nbGVBcGlNYW5hZ2VyIHtcbiAgICBpZiAoIUdvb2dsZUFwaU1hbmFnZXIuaW5zdGFuY2UpIHtcbiAgICAgIEdvb2dsZUFwaU1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgR29vZ2xlQXBpTWFuYWdlcigpO1xuICAgIH1cbiAgICByZXR1cm4gR29vZ2xlQXBpTWFuYWdlci5pbnN0YW5jZTtcbiAgfVxuXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmluaXRQcm9taXNlKSByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcblxuICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLmRvSW5pdGlhbGl6ZSgpO1xuICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBkb0luaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIGNyZWRlbnRpYWxzIGFyZSBhdmFpbGFibGVcbiAgICAgIGlmICghQ0xJRU5UX0lEIHx8ICFBUElfS0VZKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR29vZ2xlIEFQSSBjcmVkZW50aWFscyBub3QgY29uZmlndXJlZC4gUGxlYXNlIHNldCBORVhUX1BVQkxJQ19HT09HTEVfQ0xJRU5UX0lEIGFuZCBORVhUX1BVQkxJQ19HT09HTEVfQVBJX0tFWSBpbiB5b3VyIC5lbnYubG9jYWwgZmlsZS4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2FpdCBmb3Igc2NyaXB0cyB0byBiZSBhdmFpbGFibGVcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvclNjcmlwdHMoKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBHQVBJXG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVHYXBpKCk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgR1NJXG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVHc2koKTtcbiAgICAgIFxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgR29vZ2xlIEFQSXM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb29nbGUgQVBJIGluaXRpYWxpemF0aW9uIGZhaWxlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd2FpdEZvclNjcmlwdHMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignR29vZ2xlIEFQSSBzY3JpcHRzIGZhaWxlZCB0byBsb2FkJykpO1xuICAgICAgfSwgMTAwMDApO1xuXG4gICAgICBjb25zdCBjaGVja1NjcmlwdHMgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZ2FwaSAmJiB3aW5kb3cuZ29vZ2xlPy5hY2NvdW50cz8ub2F1dGgyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNoZWNrU2NyaXB0cywgMTAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY2hlY2tTY3JpcHRzKCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVHYXBpKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXdpbmRvdy5nYXBpKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0dBUEkgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aW5kb3cuZ2FwaS5sb2FkKCdjbGllbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmluaXQoe1xuICAgICAgICAgICAgYXBpS2V5OiBBUElfS0VZLFxuICAgICAgICAgICAgZGlzY292ZXJ5RG9jczogWydodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9kaXNjb3ZlcnkvdjEvYXBpcy9kcml2ZS92My9yZXN0J10sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dBUEkgY2xpZW50IGluaXRpYWxpemF0aW9uIGVycm9yIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBHQVBJIGNsaWVudDogJHtlcnJvci5tZXNzYWdlfWApKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgR0FQSSBjbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplR3NpKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXdpbmRvdy5nb29nbGU/LmFjY291bnRzPy5vYXV0aDIpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdHb29nbGUgSWRlbnRpdHkgU2VydmljZXMgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRva2VuQ2xpZW50ID0gd2luZG93Lmdvb2dsZS5hY2NvdW50cy5vYXV0aDIuaW5pdFRva2VuQ2xpZW50KHtcbiAgICAgICAgICBjbGllbnRfaWQ6IENMSUVOVF9JRCxcbiAgICAgICAgICBzY29wZTogU0NPUEVTLFxuICAgICAgICAgIGNhbGxiYWNrOiAodG9rZW5SZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZXNwb25zZSAmJiB0b2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICB3aW5kb3cuZ2FwaS5jbGllbnQuc2V0VG9rZW4oeyBhY2Nlc3NfdG9rZW46IHRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3JfY2FsbGJhY2s6IChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHU0kgRXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgR29vZ2xlIElkZW50aXR5IFNlcnZpY2VzJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2lnbkluKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy50b2tlbkNsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb29nbGUgQVBJIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMudG9rZW5DbGllbnQpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVG9rZW4gY2xpZW50IG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3JpZ2luYWxDYWxsYmFjayA9IHRoaXMudG9rZW5DbGllbnQuY2FsbGJhY2s7XG4gICAgICB0aGlzLnRva2VuQ2xpZW50LmNhbGxiYWNrID0gKHRva2VuUmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICBpZiAob3JpZ2luYWxDYWxsYmFjaykgb3JpZ2luYWxDYWxsYmFjayh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHRva2VuUmVzcG9uc2UgJiYgdG9rZW5SZXNwb25zZS5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2Nlc3MgdG9rZW4nKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMudG9rZW5DbGllbnQucmVxdWVzdEFjY2Vzc1Rva2VuKHsgcHJvbXB0OiAnY29uc2VudCcgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzaWduT3V0KCk6IHZvaWQge1xuICAgIGlmICh3aW5kb3cuZ2FwaT8uY2xpZW50KSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHdpbmRvdy5nYXBpLmNsaWVudC5nZXRUb2tlbigpO1xuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIHdpbmRvdy5nb29nbGUuYWNjb3VudHMub2F1dGgyLnJldm9rZSh0b2tlbi5hY2Nlc3NfdG9rZW4sICgpID0+IHt9KTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5nYXBpLmNsaWVudC5zZXRUb2tlbihudWxsKTtcbiAgICB9XG4gIH1cblxuICBpc1NpZ25lZEluKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhISh3aW5kb3cuZ2FwaT8uY2xpZW50Py5nZXRUb2tlbigpPy5hY2Nlc3NfdG9rZW4pO1xuICB9XG5cbiAgYXN5bmMgdXBsb2FkRmlsZShibG9iOiBCbG9iLCBmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuaXNTaWduZWRJbigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzaWduZWQgaW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgIG5hbWU6IGZpbGVuYW1lLFxuICAgICAgbWltZVR5cGU6IGJsb2IudHlwZSxcbiAgICB9O1xuXG4gICAgY29uc3QgZm9ybUJvZHkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtQm9keS5hcHBlbmQoJ21ldGFkYXRhJywgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KG1ldGFkYXRhKV0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pKTtcbiAgICBmb3JtQm9keS5hcHBlbmQoJ2ZpbGUnLCBibG9iKTtcblxuICAgIGNvbnN0IHRva2VuID0gd2luZG93LmdhcGkuY2xpZW50LmdldFRva2VuKCk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG9rZW4gYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vdXBsb2FkL2RyaXZlL3YzL2ZpbGVzP3VwbG9hZFR5cGU9bXVsdGlwYXJ0Jywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VuLmFjY2Vzc190b2tlbn1gXG4gICAgICB9LFxuICAgICAgYm9keTogZm9ybUJvZHksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVwbG9hZCBmYWlsZWQ6ICR7ZXJyb3JUZXh0fWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRyaXZlRmlsZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIC8vIE1ha2UgZmlsZSBwdWJsaWNcbiAgICBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUucGVybWlzc2lvbnMuY3JlYXRlKHtcbiAgICAgIGZpbGVJZDogZHJpdmVGaWxlLmlkLFxuICAgICAgcmVzb3VyY2U6IHsgcm9sZTogJ3JlYWRlcicsIHR5cGU6ICdhbnlvbmUnIH1cbiAgICB9KTtcblxuICAgIC8vIEdldCBwdWJsaWMgbGlua1xuICAgIGNvbnN0IGZpbGVEZXRhaWxzID0gYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmRyaXZlLmZpbGVzLmdldCh7XG4gICAgICBmaWxlSWQ6IGRyaXZlRmlsZS5pZCxcbiAgICAgIGZpZWxkczogJ3dlYlZpZXdMaW5rJ1xuICAgIH0pO1xuXG4gICAgY29uc3QgcHVibGljTGluayA9IGZpbGVEZXRhaWxzLnJlc3VsdC53ZWJWaWV3TGluaztcbiAgICBpZiAoIXB1YmxpY0xpbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJldHJpZXZlIHB1YmxpYyBsaW5rJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1YmxpY0xpbms7XG4gIH1cbn0iXSwibmFtZXMiOlsiQ0xJRU5UX0lEIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0dPT0dMRV9DTElFTlRfSUQiLCJBUElfS0VZIiwiTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkiLCJTQ09QRVMiLCJHb29nbGVBcGlNYW5hZ2VyIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImluaXRpYWxpemUiLCJpc0luaXRpYWxpemVkIiwiaW5pdFByb21pc2UiLCJkb0luaXRpYWxpemUiLCJFcnJvciIsIndhaXRGb3JTY3JpcHRzIiwiaW5pdGlhbGl6ZUdhcGkiLCJpbml0aWFsaXplR3NpIiwiZXJyb3IiLCJjb25zb2xlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImNoZWNrU2NyaXB0cyIsIndpbmRvdyIsImdhcGkiLCJnb29nbGUiLCJhY2NvdW50cyIsIm9hdXRoMiIsImNsZWFyVGltZW91dCIsImxvYWQiLCJjbGllbnQiLCJpbml0IiwiYXBpS2V5IiwiZGlzY292ZXJ5RG9jcyIsIm1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwidG9rZW5DbGllbnQiLCJpbml0VG9rZW5DbGllbnQiLCJjbGllbnRfaWQiLCJzY29wZSIsImNhbGxiYWNrIiwidG9rZW5SZXNwb25zZSIsImFjY2Vzc190b2tlbiIsInNldFRva2VuIiwiZXJyb3JfY2FsbGJhY2siLCJzaWduSW4iLCJvcmlnaW5hbENhbGxiYWNrIiwicmVxdWVzdEFjY2Vzc1Rva2VuIiwicHJvbXB0Iiwic2lnbk91dCIsInRva2VuIiwiZ2V0VG9rZW4iLCJyZXZva2UiLCJpc1NpZ25lZEluIiwidXBsb2FkRmlsZSIsImJsb2IiLCJmaWxlbmFtZSIsIm1ldGFkYXRhIiwibmFtZSIsIm1pbWVUeXBlIiwidHlwZSIsImZvcm1Cb2R5IiwiRm9ybURhdGEiLCJhcHBlbmQiLCJCbG9iIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZHJpdmVGaWxlIiwianNvbiIsImRyaXZlIiwicGVybWlzc2lvbnMiLCJjcmVhdGUiLCJmaWxlSWQiLCJpZCIsInJlc291cmNlIiwicm9sZSIsImZpbGVEZXRhaWxzIiwiZmlsZXMiLCJnZXQiLCJmaWVsZHMiLCJwdWJsaWNMaW5rIiwicmVzdWx0Iiwid2ViVmlld0xpbmsiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/google-api.ts\n"));

/***/ })

});